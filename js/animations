function revealEllipses() {
    const ellipses = [];

    // collect ellipses
    for (let i = 1; i <= 6; i++) {
        const ellipse = document.getElementById(`ellipse${i}`);
        if (ellipse) {
            ellipses.push(ellipse);
        }
    }

    ellipses.forEach((ellipse, index) => {
        //initial styles
        ellipse.style.opacity = '0';
        ellipse.style.transition = `opacity 0.5s ease ${index * 0.1}s`; // Adjust the delay as needed

        //opacity change
        setTimeout(() => {
            ellipse.style.opacity = '1';
        }, 50); //delay in milliseconds
    });
}

// Get the header element
const header = document.querySelector('.header');

//store scroll position and timeout ID
let isScrolling;
let scrollTimeout;

//scroll events
function handleScroll() {
    // clear timeout
    clearTimeout(scrollTimeout);

    // hide header when scrolling down
    header.classList.add('hidden');

    // show header after 1000 milliseconds of no scrolling
    scrollTimeout = setTimeout(() => {
        header.classList.remove('hidden');
    }, 1000);

    /*
    // Clear the isScrolling flag after 250 milliseconds of no scrolling
    clearTimeout(isScrolling);
    isScrolling = setTimeout(() => {
        header.classList.remove('hidden');
    }, 250);
    */
}

// Get all ellipses on page1
const ellipses = document.querySelectorAll('.q1 .ellipse');
const oppositeEllipses = document.querySelectorAll('.q2 .el'); // Add the class 'opposite-ellipse' to the second set

// Function to handle the fading effect
function handleScrollFade() {
    // Calculate the scroll position
    const scrollPosition = window.scrollY;

    // Iterate through the first set of ellipses
    ellipses.forEach(ellipse => {
        // Calculate the distance from the top of the ellipse to the viewport top
        const distanceFromTop = ellipse.getBoundingClientRect().top;

        // Calculate the opacity based on the scroll position
        const opacity = 1 - Math.min(Math.max(distanceFromTop / 10, 0), 1);

        // Apply the opacity to the ellipse
        ellipse.style.opacity = opacity.toFixed(2);

        // Reset opacity to 1 when scrolling back up
        if (scrollPosition < 10) {
            ellipse.style.opacity = '1';
        }
    });

    // Iterate through the second set of ellipses
    oppositeEllipses.forEach(oppositeEllipse => {
        // Calculate the distance from the top of the opposite ellipse to the viewport top
        const distanceFromTop = oppositeEllipse.getBoundingClientRect().top;

        // Calculate the opposite opacity based on the scroll position
        const oppositeOpacity = Math.min(Math.max(distanceFromTop / 10, 0), 1);

        // Apply the opposite opacity to the opposite ellipse
        oppositeEllipse.style.opacity = oppositeOpacity.toFixed(2);

        // Reset opacity to 0 when scrolling back up
        if (scrollPosition < 10) {
            oppositeEllipse.style.opacity = '0';
        }
    });
}


// Attach the handleScrollFade function to the scroll event
window.addEventListener('scroll', handleScrollFade);

window.addEventListener('scroll', handleScroll);
window.addEventListener('load unload', revealEllipses);